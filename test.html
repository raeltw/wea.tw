<!DOCTYPE html>
<html>
<head>
<title>圓形弧線水平線填色測試 (V17 - 函數化呼叫)</title>
<style>
  body {
    display: flex;
    flex-wrap: wrap;
    justify-content: flex-start;
    align-items: flex-start;
    padding: 20px;
    font-family: sans-serif;
  }
  .section-title {
    width: 100%;
    margin-top: 20px;
    margin-bottom: 10px;
    font-size: 18px;
    font-weight: bold;
    color: #333;
    border-bottom: 1px solid #ccc;
    padding-bottom: 5px;
  }
  .canvas-container {
    margin: 10px;
    border: 1px solid #ccc;
    box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
    position: relative; /* 用于版本信息的定位 */
  }
  canvas {
    background-color: #f9f9f9;
  }
  .label {
    text-align: center;
    font-size: 14px;
    margin-top: 5px;
    color: #555;
  }
  .version-info-box {
    position: absolute; /* 相对于父容器定位 */
    top: 5px;
    right: 5px;
    font-size: 10px;
    color: #999;
    background-color: rgba(255, 255, 255, 0.7);
    padding: 2px 5px;
    border-radius: 3px;
  }
  /* 測試用的容器 div 樣式 */
  .drawing-group-container { /* 使用一個共同的 class */
      border: 2px dashed #90EE90; 
      padding: 10px;
      margin: 20px 0;
      width: 100%; 
      box-sizing: border-box;
      display: flex;
      flex-wrap: wrap;
      justify-content: flex-start;
      align-items: flex-start;
  }
</style>
</head>
<body>

<div class="section-title">第一組: 紅線左側塗黑，右側塗白 (0-100) - 由 funcm1() 呼叫</div>
<div id="group1Div" class="drawing-group-container">
    </div>


<div class="section-title" style="clear: both;">第二組: 紅線左側塗白，右側塗黑 (0-100) - 由 funcm2() 呼叫</div>
<div id="group2Div" class="drawing-group-container">
    </div>

<div class="section-title" style="clear: both;">額外測試組: 由 funcm1() 呼叫，不同尺寸</div>
<div id="extraTestDiv" class="drawing-group-container">
    </div>


<script>
  const gridSize = 10; 
  const renderDensity = 1; // 填充細緻度

  // 核心繪圖邏輯函數 (內部使用，不直接對外暴露)
  function _drawInternal(canvasId, angleValue, fillLeftBlack, targetDivId, newCanvasWidth, newCanvasHeight) {
    const container = document.createElement('div');
    container.className = 'canvas-container';

    const canvas = document.createElement('canvas');
    canvas.id = canvasId;
    canvas.width = newCanvasWidth;
    canvas.height = newCanvasHeight;
    container.appendChild(canvas);

    const label = document.createElement('div');
    label.className = 'label';
    label.textContent = `角度值: ${angleValue} (${newCanvasWidth}x${newCanvasHeight})`;
    container.appendChild(label);

    const versionBox = document.createElement('div');
    versionBox.className = 'version-info-box';
    versionBox.textContent = 'V17'; 
    container.appendChild(versionBox);

    const targetDiv = document.getElementById(targetDivId);
    if (targetDiv) {
        targetDiv.appendChild(container);
    } else {
        console.error(`找不到 ID 為 "${targetDivId}" 的容器 div。將圖形添加到 body。`);
        document.body.appendChild(container); 
    }

    const ctx = canvas.getContext('2d');
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    const circleRadius = Math.min(canvas.width, canvas.height) / 2 - 5; 

    const observationAngleRadians = (angleValue / 100) * Math.PI;

    const semiMinorAxis_horizontal = circleRadius * Math.cos(observationAngleRadians);
    const semiMajorAxis_vertical = circleRadius; 
    const currentAbsoluteSemiMinorAxis = Math.abs(semiMinorAxis_horizontal); 

    // 1. 繪製整個圓形背景為白色
    ctx.beginPath();
    ctx.arc(centerX, centerY, circleRadius, 0, 2 * Math.PI);
    ctx.fillStyle = 'white';
    ctx.fill();

    // --- 水平掃描線填充邏輯 ---
    for (let y = centerY - circleRadius; y <= centerY + circleRadius; y += renderDensity) {
      const dy = y - centerY;
      const dxGreen = Math.sqrt(Math.pow(circleRadius, 2) - Math.pow(dy, 2));
      const greenLeftX = centerX - dxGreen;
      const greenRightX = centerX + dxGreen;

      let redArcX = null; 

      const discriminant = 1 - Math.pow(dy, 2) / Math.pow(semiMajorAxis_vertical, 2);
      
      if (discriminant >= 0) { 
        const dxRed = currentAbsoluteSemiMinorAxis * Math.sqrt(discriminant);
        
        if (semiMinorAxis_horizontal >= 0) { 
            redArcX = centerX + dxRed;
        } else { 
            redArcX = centerX - dxRed;
        }
      }
      
      if (redArcX !== null) {
          redArcX = Math.max(greenLeftX, Math.min(greenRightX, redArcX));
      } else {
          if (semiMinorAxis_horizontal >= 0) { 
              redArcX = greenLeftX; 
          } else { 
              redArcX = greenRightX; 
          }
      }

      ctx.fillStyle = fillLeftBlack ? 'black' : 'white';
      ctx.fillRect(greenLeftX, y, redArcX - greenLeftX, renderDensity);

      ctx.fillStyle = fillLeftBlack ? 'white' : 'black';
      ctx.fillRect(redArcX, y, greenRightX - redArcX, renderDensity);
    }


    // 2. 繪製綠色圓形邊框，確保在填充之上
    ctx.beginPath();
    ctx.arc(centerX, centerY, circleRadius, 0, 2 * Math.PI);
    ctx.strokeStyle = 'green';
    ctx.lineWidth = 1;
    ctx.stroke();

    // 3. 繪製紅色弧線，確保在填充之上
    let redArcOutlineStartAngle, redArcOutlineEndAngle;
    if (semiMinorAxis_horizontal >= 0) { 
        redArcOutlineStartAngle = -Math.PI / 2;
        redArcOutlineEndAngle = Math.PI / 2;
    } else { 
        redArcOutlineStartAngle = Math.PI / 2;
        redArcOutlineEndAngle = 3 * Math.PI / 2;
    }

    ctx.beginPath();
    const redOutlinePoint1X = centerX + currentAbsoluteSemiMinorAxis * Math.cos(redArcOutlineStartAngle);
    const redOutlinePoint1Y = centerY + semiMajorAxis_vertical * Math.sin(redArcOutlineStartAngle);
    
    ctx.moveTo(redOutlinePoint1X, redOutlinePoint1Y);
    const numSegments = 100;
    for (let i = 0; i <= numSegments; i++) {
        const t = redArcOutlineStartAngle + (redArcOutlineEndAngle - redArcOutlineStartAngle) * (i / numSegments);
        const x = centerX + currentAbsoluteSemiMinorAxis * Math.cos(t);
        const y = centerY + semiMajorAxis_vertical * Math.sin(t);
        ctx.lineTo(x, y);
    }
    ctx.strokeStyle = 'red';
    ctx.lineWidth = 3;
    ctx.stroke();

    // 繪製中心點 (藍色)
    ctx.beginPath();
    ctx.arc(centerX, centerY, 2, 0, 2 * Math.PI);
    ctx.fillStyle = 'blue';
    ctx.fill();
  }

  // --- 對外暴露的調用函數 ---

  /**
   * 繪製第一組圖形 (紅線左側塗黑，右側塗白)。
   * 會生成 11 個從角度值 0 到 100 的圖形。
   * @param {string} targetDivId - 要將圖形添加到哪個 div 的 ID。
   * @param {number} size - 每個圖形的寬高 (例如 200 表示 200x200 像素)。
   */
  function funcm1(targetDivId, size) {
      for (let i = 0; i <= gridSize; i++) {
          const angleValue = i * 10;
          // 注意：為確保每個 canvas 的 ID 唯一，加上了 targetDivId 和 size 的後綴
          _drawInternal(`canvas_${targetDivId}_m1_${angleValue}_${size}`, angleValue, true, targetDivId, size, size); 
      }
  }

  /**
   * 繪製第二組圖形 (紅線左側塗白，右側塗黑)。
   * 會生成 11 個從角度值 0 到 100 的圖形。
   * @param {string} targetDivId - 要將圖形添加到哪個 div 的 ID。
   * @param {number} size - 每個圖形的寬高 (例如 200 表示 200x200 像素)。
   */
  function funcm2(targetDivId, size) {
      for (let i = 0; i <= gridSize; i++) {
          const angleValue = i * 10;
          _drawInternal(`canvas_${targetDivId}_m2_${angleValue}_${size}`, angleValue, false, targetDivId, size, size); 
      }
  }

  // --- 頁面加載後調用這些函數來生成圖形 ---
  // 第一組示例
  funcm1('group1Div', 200); 

  // 第二組示例
  funcm2('group2Div', 250); 

  // 額外測試組示例：使用 funcm1 且不同尺寸
  funcm1('extraTestDiv', 150);
  funcm1('extraTestDiv', 220); // 同一個 div 內不同尺寸的測試

</script>

</body>
</html>