<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>球體弧形切割動畫 (黑底白球版)</title>
    <style>
        /* 確保 body 和 canvas 都填滿整個視窗，且背景為黑色 */
        body {
            margin: 0;
            overflow: hidden; /* 避免滾動條 */
            background-color: #000; /* 純黑色背景 */
            display: flex; /* 使用 Flexbox 確保 canvas 居中 */
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* 確保 body 至少有視窗高度 */
            color: #eee; /* 文字顏色 */
            font-family: sans-serif;
            font-size: 14px;
        }
        canvas {
            display: block; /* 移除圖片底部預設的空白 */
            /* 讓 canvas 填滿視窗，確保沒有邊緣被切掉 */
            width: 100vw;
            height: 100vh;
        }
        #version-info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.5); /* 半透明黑色背景 */
            padding: 5px 10px;
            border-radius: 5px;
            z-index: 100; /* 確保在 canvas 上方 */
        }
    </style>
</head>
<body>
    <div id="version-info">版本: v2025.07.05.2</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.165.0/three.min.js"></script>

    <script>
        // --- 設定版本號 ---
        const VERSION = 'v2025.07.05.2'; // **版本號已更新**
        document.getElementById('version-info').innerText = `版本: ${VERSION}`;

        // --- 設定 Three.js 場景 ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); // alpha: true 讓背景透明，與 body 背景融合
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // 關鍵：啟用渲染器的局部裁剪功能
        renderer.localClippingEnabled = true;

        // --- 建立一個**純白色球體** ---
        const sphereRadius = 2;
        const sphereGeometry = new THREE.SphereGeometry(sphereRadius, 64, 64);
        const sphereMaterial = new THREE.MeshLambertMaterial({
            color: 0xffffff, // **純白色**
            side: THREE.DoubleSide // 讓材質在兩面都可見
        });
        const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
        scene.add(sphere);

        // 調整相機位置，以便看到整個球體
        camera.position.set(0, 0, 5);

        // --- 設定光源 (讓白色球體看得見陰影和立體感) ---
        // 環境光：提供基本亮度
        const ambientLight = new THREE.AmbientLight(0x404040, 2); // 顏色，強度
        scene.add(ambientLight);

        // 定向光：模擬主要光源方向
        const directionalLight = new THREE.DirectionalLight(0xffffff, 2); // 顏色，強度
        directionalLight.position.set(1, 1, 1).normalize(); // 從 (1,1,1) 方向照射
        scene.add(directionalLight);

        // --- 核心：設定裁剪平面來模擬切割 ---
        const clippingPlane = new THREE.Plane(new THREE.Vector3(1, 0, 0), -sphereRadius);
        sphereMaterial.clippingPlanes = [clippingPlane];
        sphereMaterial.needsUpdate = true;

        // --- 動畫迴圈 ---
        let currentCutPosition = -sphereRadius;
        const cutSpeed = 0.01;

        function animate() {
            requestAnimationFrame(animate);

            sphere.rotation.y += 0.005;

            if (currentCutPosition <= sphereRadius) {
                currentCutPosition += cutSpeed;
                clippingPlane.constant = -currentCutPosition;

                if (currentCutPosition > sphereRadius) {
                    console.log("球體已完全切割消失！");
                    // 這裡可以選擇重置動畫
                    // currentCutPosition = -sphereRadius;
                }
            }

            renderer.render(scene, camera);
        }

        animate();

        // --- 處理視窗大小改變 ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>