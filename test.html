<!DOCTYPE html>
<html>
<head>
<title>切西瓜弧線填色測試 (V5)</title>
<style>
  body {
    display: flex;
    flex-wrap: wrap;
    justify-content: flex-start;
    align-items: flex-start;
    padding: 20px;
    font-family: sans-serif;
  }
  .section-title {
    width: 100%;
    margin-top: 20px;
    margin-bottom: 10px;
    font-size: 18px;
    font-weight: bold;
    color: #333;
    border-bottom: 1px solid #ccc;
    padding-bottom: 5px;
  }
  .canvas-container {
    margin: 10px;
    border: 1px solid #ccc;
    box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
    position: relative; /* 用于版本信息的定位 */
  }
  canvas {
    background-color: #f9f9f9;
  }
  .label {
    text-align: center;
    font-size: 14px;
    margin-top: 5px;
    color: #555;
  }
  .version-info-box {
    position: absolute; /* 相对于父容器定位 */
    top: 5px;
    right: 5px;
    font-size: 10px;
    color: #999;
    background-color: rgba(255, 255, 255, 0.7);
    padding: 2px 5px;
    border-radius: 3px;
  }
</style>
</head>
<body>

<div class="section-title">第一組: 红线左侧涂黑 (0-100)</div>

<script>
  const gridSize = 10; // 从 0 到 100，每10为一个增量，所以有 11 个图 (0, 10, ..., 100)
  const canvasWidth = 200;
  const canvasHeight = 200;
  const watermelonRadius = 80; // 西瓜的半徑 (像素)

  // 辅助函数：绘制单个弧线和填充
  function drawArcAndFill(canvasId, angleValue, fillSide) { // fillSide: 'left' or 'right'
    const container = document.createElement('div');
    container.className = 'canvas-container';

    const canvas = document.createElement('canvas');
    canvas.id = canvasId;
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;
    container.appendChild(canvas);

    const label = document.createElement('div');
    label.className = 'label';
    label.textContent = `角度值: ${angleValue}`;
    container.appendChild(label);

    // 独立添加版本信息到每个 canvas container
    const versionBox = document.createElement('div');
    versionBox.className = 'version-info-box';
    versionBox.textContent = 'V5'; // 每次更新版本号
    container.appendChild(versionBox);

    document.body.appendChild(container);

    const ctx = canvas.getContext('2d');
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;

    // 将 0-100 的值映射到 0 到 Math.PI 弧度
    // 0 (正東) -> 0 弧度 (正視，看到右側圓形)
    // 50 (正南) -> Math.PI / 2 弧度 (側視，看到豎直線)
    // 100 (正西) -> Math.PI 弧度 (反向正視，看到左側圓形)
    const observationAngleRadians = (angleValue / 100) * Math.PI;

    // 水平方向的轴长会因为倾斜而缩短
    const semiMinorAxis_horizontal = watermelonRadius * Math.cos(observationAngleRadians);
    // 垂直方向的轴长保持不变 (西瓜半径)
    const semiMajorAxis_vertical = watermelonRadius;

    // 确定绘制椭圆的哪半部分以及填充方向
    let arcStart, arcEnd;
    let fillPathStartPoint, fillPathEndPoint; // 用于连接到圆弧边界的点

    // 注意：这里的 currentSemiMinorAxis 是带正负的，用于判断是面对还是背对
    const currentSemiMinorAxis = semiMinorAxis_horizontal; // 沿用之前计算的带符号的半短轴

    if (currentSemiMinorAxis >= 0) { // 面对我们（右半边）
        arcStart = -Math.PI / 2;
        arcEnd = Math.PI / 2;
        // 填充时需要连接到圆的左侧边缘
        fillPathStartPoint = { x: centerX + watermelonRadius * Math.cos(arcEnd), y: centerY + watermelonRadius * Math.sin(arcEnd) };
        fillPathEndPoint = { x: centerX + watermelonRadius * Math.cos(arcStart), y: centerY + watermelonRadius * Math.sin(arcStart) };

    } else { // 背向我们（左半边）
        arcStart = Math.PI / 2;
        arcEnd = 3 * Math.PI / 2;
        // 填充时需要连接到圆的右侧边缘
        fillPathStartPoint = { x: centerX + watermelonRadius * Math.cos(arcEnd), y: centerY + watermelonRadius * Math.sin(arcEnd) };
        fillPathEndPoint = { x: centerX + watermelonRadius * Math.cos(arcStart), y: centerY + watermelonRadius * Math.sin(arcStart) };
    }

    // *** 填充区域绘制逻辑 ***
    ctx.beginPath();

    // 1. 移动到弧线的起点
    const initialT = arcStart;
    const initialX = centerX + Math.abs(currentSemiMinorAxis) * Math.cos(initialT);
    const initialY = centerY + semiMajorAxis_vertical * Math.sin(initialT);
    ctx.moveTo(initialX, initialY);

    // 2. 绘制红色弧线
    const numSegments = 100;
    for (let i = 0; i <= numSegments; i++) {
      const t = arcStart + (arcEnd - arcStart) * (i / numSegments);
      const x = centerX + Math.abs(currentSemiMinorAxis) * Math.cos(t);
      const y = centerY + semiMajorAxis_vertical * Math.sin(t);
      ctx.lineTo(x, y);
    }
    // 当前路径的终点是弧线的终点

    // 3. 连接到西瓜轮廓的边缘并填充
    if (fillSide === 'left') { // 填充红色弧线的左侧 (也就是切面内部，更靠近中心的那一半)
        // 从弧线终点连接到圆的左边缘
        // 这里的逻辑需要根据 currentSemiMinorAxis 的正负来判断“左侧”
        if (currentSemiMinorAxis >= 0) { // 面对我们，右半圆，其“左侧”是沿着圆弧向内
             // 连接到西瓜圆的左边点 (圆心左侧 watermelonRadius 距离)
             ctx.lineTo(centerX - watermelonRadius, centerY); // 连接到最左侧点
             ctx.arc(centerX, centerY, watermelonRadius, Math.PI, Math.PI / 2, true); // 沿圆弧到上边缘 (逆时针)
             ctx.lineTo(initialX, initialY); // 再连回弧线起点
        } else { // 背向我们，左半圆，其“左侧”是沿着圆弧向外
             // 连接到西瓜圆的左边点 (圆心左侧 watermelonRadius 距离)
             ctx.lineTo(centerX - watermelonRadius, centerY); // 连接到最左侧点
             ctx.arc(centerX, centerY, watermelonRadius, Math.PI, 3 * Math.PI / 2, true); // 沿圆弧到下边缘 (逆时针)
             ctx.lineTo(initialX, initialY); // 再连回弧线起点
        }
    } else if (fillSide === 'right') { // 填充红色弧线的右侧 (也就是切面外部，远离中心的那一半)
        // 这里的逻辑需要根据 currentSemiMinorAxis 的正负来判断“右侧”
        if (currentSemiMinorAxis >= 0) { // 面对我们，右半圆，其“右侧”是沿着圆弧向外
            // 连接到西瓜圆的右边点 (圆心右侧 watermelonRadius 距离)
            ctx.lineTo(centerX + watermelonRadius, centerY); // 连接到最右侧点
            ctx.arc(centerX, centerY, watermelonRadius, 0, Math.PI / 2, false); // 沿圆弧到上边缘 (顺时针)
            ctx.lineTo(initialX, initialY); // 再连回弧线起点
        } else { // 背向我们，左半圆，其“右侧”是沿着圆弧向内
            // 连接到西瓜圆的右边点 (圆心右侧 watermelonRadius 距离)
            ctx.lineTo(centerX + watermelonRadius, centerY); // 连接到最右侧点
            ctx.arc(centerX, centerY, watermelonRadius, 0, 3 * Math.PI / 2, true); // 沿圆弧到下边缘 (逆时针)
            ctx.lineTo(initialX, initialY); // 再连回弧线起点
        }
    }

    // 重新思考填充逻辑
    // 最简单且一致的填充方法是始终填充“刀痕”与“西瓜边缘”之间的区域
    // 也就是将椭圆弧和西瓜外圆弧连接起来形成一个闭合路径。
    // 但是要区分左右侧，则需要更精细的路径控制。
    // 简化方案：画出半个西瓜，然后填充它的左侧或右侧。

    // 绘制填充区域的通用逻辑
    ctx.beginPath();
    // 1. 从弧线的起点开始
    const startPointX = centerX + Math.abs(currentSemiMinorAxis) * Math.cos(arcStart);
    const startPointY = centerY + semiMajorAxis_vertical * Math.sin(arcStart);
    ctx.moveTo(startPointX, startPointY);

    // 2. 绘制弧线
    for (let i = 0; i <= numSegments; i++) {
        const t = arcStart + (arcEnd - arcStart) * (i / numSegments);
        const x = centerX + Math.abs(currentSemiMinorAxis) * Math.cos(t);
        const y = centerY + semiMajorAxis_vertical * Math.sin(t);
        ctx.lineTo(x, y);
    }
    const endPointX = centerX + Math.abs(currentSemiMinorAxis) * Math.cos(arcEnd);
    const endPointY = centerY + semiMajorAxis_vertical * Math.sin(arcEnd);

    // 3. 连接到西瓜的外部圆周
    // 假设弧线的两个端点在 Y 轴方向上的位置是 (x1, y1) 和 (x2, y2)
    // 我们需要沿着绿色的圆弧连接这两个点。
    // 获取弧线端点相对于圆心的角度
    const angleStartOnCircle = Math.atan2(startPointY - centerY, startPointX - centerX);
    const angleEndOnCircle = Math.atan2(endPointY - centerY, endPointX - centerX);

    if (fillSide === 'left') { // 填充弧线左侧（西瓜的内部，靠近中心的部分）
        // 路径应该从弧线终点，沿直线到圆心，再沿直线到弧线起点。
        // 或者，从弧线终点，沿西瓜圆周的“内侧”到弧线起点。
        // 但这里为了模拟切面，更像是填充被切开的半边。

        // 更好的理解：填充的是切面形成的半个西瓜。
        // 我们可以直接画一个半圆，然后填充。
        // 而“红色弧线”是这个半圆的“可視邊界”。

        // 绘制一个“扇形”区域
        ctx.lineTo(centerX, centerY); // 连接到圆心
        ctx.closePath(); // 闭合路径，形成一个三角形或扇形
        // ctx.arc(centerX, centerY, watermelonRadius, angleStartOnCircle, angleEndOnCircle, true); // 沿圆弧连接

    } else if (fillSide === 'right') { // 填充弧线右侧 (另一半)
        // 类似地，填充另一半扇形
        ctx.lineTo(centerX, centerY); // 连接到圆心
        ctx.closePath(); // 闭合路径
    }


    // --- 最终填充逻辑调整 ---
    // 为了实现左右填充，我们需要绘制半个西瓜的形状，然后填充它。
    // “红色弧线”是分割线。

    // 首先绘制整个西瓜轮廓 (绿色)
    ctx.beginPath();
    ctx.arc(centerX, centerY, watermelonRadius, 0, 2 * Math.PI);
    ctx.strokeStyle = 'green';
    ctx.lineWidth = 1;
    ctx.stroke();

    // 然后绘制红色弧线
    ctx.beginPath();
    const currentAbsoluteSemiMinorAxis = Math.abs(semiMinorAxis_horizontal);

    // 计算实际的弧线起始和结束角度
    let redArcStartAngle, redArcEndAngle;
    if (currentSemiMinorAxis >= 0) { // 右半边
        redArcStartAngle = -Math.PI / 2;
        redArcEndAngle = Math.PI / 2;
    } else { // 左半边
        redArcStartAngle = Math.PI / 2;
        redArcEndAngle = 3 * Math.PI / 2;
    }

    // 获取红色弧线的两端点
    const redArcPoint1X = centerX + currentAbsoluteSemiMinorAxis * Math.cos(redArcStartAngle);
    const redArcPoint1Y = centerY + semiMajorAxis_vertical * Math.sin(redArcStartAngle);
    const redArcPoint2X = centerX + currentAbsoluteSemiMinorAxis * Math.cos(redArcEndAngle);
    const redArcPoint2Y = centerY + semiMajorAxis_vertical * Math.sin(redArcEndAngle);


    // --- 填色逻辑 ---
    // 为了填充“左侧”或“右侧”，我们需要构建一个由红色弧线和绿色圆弧组成的闭合路径。
    ctx.beginPath();

    if (fillSide === 'left') { // 填充左侧（也就是弧线和圆圈左侧边缘之间的区域）
        if (currentSemiMinorAxis >= 0) { // 右半椭圆可见，填充其左边区域
            // 从红线左下角开始，沿红线到右上角
            ctx.moveTo(redArcPoint1X, redArcPoint1Y);
            for (let i = 0; i <= numSegments; i++) {
                const t = redArcStartAngle + (redArcEndAngle - redArcStartAngle) * (i / numSegments);
                const x = centerX + currentAbsoluteSemiMinorAxis * Math.cos(t);
                const y = centerY + semiMajorAxis_vertical * Math.sin(t);
                ctx.lineTo(x, y);
            }
            // 从红线上方终点沿外圆逆时针到红线下方起点
            ctx.arc(centerX, centerY, watermelonRadius, redArcEndAngle, redArcStartAngle, true);
        } else { // 左半椭圆可见，填充其左边区域
            // 从红线右下角开始，沿红线到左上角
            ctx.moveTo(redArcPoint1X, redArcPoint1Y);
            for (let i = 0; i <= numSegments; i++) {
                const t = redArcStartAngle + (redArcEndAngle - redArcStartAngle) * (i / numSegments);
                const x = centerX + currentAbsoluteSemiMinorAxis * Math.cos(t);
                const y = centerY + semiMajorAxis_vertical * Math.sin(t);
                ctx.lineTo(x, y);
            }
            // 从红线上方终点沿外圆逆时针到红线下方起点
            ctx.arc(centerX, centerY, watermelonRadius, redArcEndAngle, redArcStartAngle, true);
        }
        ctx.fillStyle = 'black'; // 左侧涂黑
    } else if (fillSide === 'right') { // 填充右侧（也就是弧线和圆圈右侧边缘之间的区域）
        if (currentSemiMinorAxis >= 0) { // 右半椭圆可见，填充其右边区域
            // 从红线右下角开始，沿外圆顺时针到红线上方起点
            ctx.moveTo(redArcPoint1X, redArcPoint1Y);
            ctx.arc(centerX, centerY, watermelonRadius, redArcStartAngle, redArcEndAngle, false);
            // 沿红线从右上方终点到右下方起点
            for (let i = numSegments; i >= 0; i--) { // 反向绘制弧线
                const t = redArcStartAngle + (redArcEndAngle - redArcStartAngle) * (i / numSegments);
                const x = centerX + currentAbsoluteSemiMinorAxis * Math.cos(t);
                const y = centerY + semiMajorAxis_vertical * Math.sin(t);
                ctx.lineTo(x, y);
            }
        } else { // 左半椭圆可见，填充其右边区域
            // 从红线左下角开始，沿外圆顺时针到红线上方起点 (此时实际是向内侧绕)
            ctx.moveTo(redArcPoint1X, redArcPoint1Y);
            ctx.arc(centerX, centerY, watermelonRadius, redArcStartAngle, redArcEndAngle, false); // 沿外圆顺时针
            // 沿红线从左上方终点到左下方起点
            for (let i = numSegments; i >= 0; i--) { // 反向绘制弧线
                const t = redArcStartAngle + (redArcEndAngle - redArcStartAngle) * (i / numSegments);
                const x = centerX + currentAbsoluteSemiMinorAxis * Math.cos(t);
                const y = centerY + semiMajorAxis_vertical * Math.sin(t);
                ctx.lineTo(x, y);
            }
        }
        ctx.fillStyle = 'black'; // 右侧涂黑
    }
    ctx.closePath();
    ctx.fill();

    // 重新绘制红色弧线，确保它在填充之上
    ctx.beginPath();
    ctx.moveTo(redArcPoint1X, redArcPoint1Y);
    for (let i = 0; i <= numSegments; i++) {
        const t = redArcStartAngle + (redArcEndAngle - redArcStartAngle) * (i / numSegments);
        const x = centerX + currentAbsoluteSemiMinorAxis * Math.cos(t);
        const y = centerY + semiMajorAxis_vertical * Math.sin(t);
        ctx.lineTo(x, y);
    }
    ctx.strokeStyle = 'red';
    ctx.lineWidth = 3;
    ctx.stroke();

    // 绘制中心点
    ctx.beginPath();
    ctx.arc(centerX, centerY, 2, 0, 2 * Math.PI);
    ctx.fillStyle = 'blue';
    ctx.fill();
  }

  // 第一組: 红线左侧涂黑 (0-100)
  for (let i = 0; i <= gridSize; i++) {
    const angleValue = i * 10;
    drawArcAndFill(`canvas_left_fill_${angleValue}`, angleValue, 'left');
  }
</script>

<div class="section-title" style="clear: both;">第二組: 红线右侧涂黑 (0-100)</div>

<script>
  // 第二組: 红线右侧涂黑 (0-100) - 使用相同的函数，但传入 'right'
  for (let i = 0; i <= gridSize; i++) {
    const angleValue = i * 10;
    drawArcAndFill(`canvas_right_fill_${angleValue}`, angleValue, 'right');
  }
</script>

</body>
</html>