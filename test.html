<!DOCTYPE html>
<html>
<head>
<title>圓形弧線水平線填色測試 (V50 - 根據各組定義修正)</title>
<style>
  body {
    display: flex;
    flex-wrap: wrap;
    justify-content: flex-start;
    align-items: flex-start;
    padding: 20px;
    font-family: sans-serif;
    background-color: #333;
  }
  .page-version-info {
    width: 100%;
    text-align: right;
    font-size: 12px;
    color: #999;
    margin-bottom: 15px;
    padding-bottom: 5px;
    border-bottom: 1px dashed #666;
  }
  .section-title {
    width: 100%;
    margin-top: 20px;
    margin-bottom: 10px;
    font-size: 18px;
    font-weight: bold;
    color: #eee;
    border-bottom: 1px solid #777;
    padding-bottom: 5px;
  }
  .canvas-container {
    margin: 10px;
    border: 1px solid #555;
    box-shadow: 2px 2px 5px rgba(0,0,0,0.5);
    position: relative;
  }
  canvas {
    background-color: black;
  }
  .label {
    text-align: center;
    font-size: 14px;
    margin-top: 5px;
    color: #ccc;
  }
  .drawing-group-container {
      border: 2px dashed #666;
      padding: 10px;
      margin: 20px 0;
      width: 100%;
      box-sizing: border-box;
      display: flex;
      flex-wrap: wrap;
      justify-content: flex-start;
      align-items: flex-start;
  }
</style>
</head>
<body>

<div class="page-version-info">當前版本: V50</div>

<div class="section-title">第一組: 顯示所有文字，顯示線條圓心 (旋轉 24.5 度)</div>
<div id="group1Div" class="drawing-group-container">
    </div>

<div class="section-title" style="clear: both;">第二組: 隱藏所有文字，顯示線條圓心 (旋轉 24.5 度)</div>
<div id="group2Div" class="drawing-group-container">
    </div>

<div class="section-title" style="clear: both;">第三組: 隱藏所有文字，隱藏所有線條圓心 (旋轉 24.5 度)</div>
<div id="group3Div" class="drawing-group-container">
    </div>

<div class="section-title" style="clear: both;">第四組: 顯示所有文字，隱藏所有線條圓心 (旋轉 24.5 度)</div>
<div id="group4Div" class="drawing-group-container">
    </div>

<div class="section-title" style="clear: both;">第五組: 隱藏所有文字，隱藏所有線條圓心 (旋轉 24.5 度)</div>
<div id="group5Div" class="drawing-group-container">
    </div>

<div class="section-title" style="clear: both;">第六組: 尺寸比較 (滿月，顯示輪廓線)</div>
<div id="group6Div" class="drawing-group-container">
    </div>

<script>
  const gridSize = 10;
  const renderDensity = 1;
  const ANTI_ALIASING_OFFSET = 0.5;
  const FIXED_ROTATION_DEGREES = 24.5;

  const MOON_COLOR_LIGHT = '#e0e0e0';
  const MOON_COLOR_DARK = 'black'; 

  // 定義月亮圖片的原始尺寸和假設的月亮圓形範圍
  const MOON_IMG_ORIGINAL_WIDTH = 256;
  const MOON_IMG_ORIGINAL_HEIGHT = 256;
  const MOON_IMG_SOURCE_X = 0;
  const MOON_IMG_SOURCE_Y = 0;
  const MOON_IMG_SOURCE_WIDTH = MOON_IMG_ORIGINAL_WIDTH;
  const MOON_IMG_SOURCE_HEIGHT = MOON_IMG_ORIGINAL_HEIGHT;

  // *** 備註位置：X 和 Y 參數在此處定義 ***
  const FIXED_RADIUS_RATIO_X = 0.935; // 比例因子 X
  const FIXED_RADIUS_OFFSET_Y = 0;  // 固定偏移量 Y

  const moonImage = new Image();
  moonImage.src = 'https://raeltw.github.io/wea.tw/moon/moon256.png';

  moonImage.onload = () => {
      funcm1('group1Div', 200, false, false); 
      funcm2('group2Div', 250, true, false); 
      funcm1('group3Div', 180, true, true); 
      funcm2('group4Div', 220, false, true); 
      funcm1('group5Div', 150, true, true); 
      
      const sizesToCompare = [100, 200, 300, 400, 500];
      // 對於第六組，傳遞 angleValue = 0 (代表滿月狀態 for funcm2 的定義)，且 hideOutlines = true
      // 這裡傳遞 fillLeftBlack = false 是因為 funcm2 的組就是用 false，保持一致。
      // 但實際上，對於 hideOutlines = true 的情況，fillLeftBlack 不影響填充，只影響紅線繪製方向。
      _drawInternal(`canvas_group6Div_m1_0_${sizesToCompare[0]}`, 0, false, 'group6Div', sizesToCompare[0], sizesToCompare[0], true, false); 
      _drawInternal(`canvas_group6Div_m1_0_${sizesToCompare[1]}`, 0, false, 'group6Div', sizesToCompare[1], sizesToCompare[1], true, false); 
      _drawInternal(`canvas_group6Div_m1_0_${sizesToCompare[2]}`, 0, false, 'group6Div', sizesToCompare[2], sizesToCompare[2], true, false); 
      _drawInternal(`canvas_group6Div_m1_0_${sizesToCompare[3]}`, 0, false, 'group6Div', sizesToCompare[3], sizesToCompare[3], true, false); 
      _drawInternal(`canvas_group6Div_m1_0_${sizesToCompare[4]}`, 0, false, 'group6Div', sizesToCompare[4], sizesToCompare[4], true, false); 
  };

  moonImage.onerror = () => {
      console.error('月亮圖片載入失敗。請檢查圖片路徑或網路連接。');
      funcm1('group1Div', 200, false, false);
      funcm2('group2Div', 250, true, false);
      funcm1('group3Div', 180, true, true);
      funcm2('group4Div', 220, false, true);
      funcm1('group5Div', 150, true, true);

      const sizesToCompare = [100, 200, 300, 400, 500];
      _drawInternal(`canvas_group6Div_m1_0_${sizesToCompare[0]}`, 0, false, 'group6Div', sizesToCompare[0], sizesToCompare[0], true, false); 
      _drawInternal(`canvas_group6Div_m1_0_${sizesToCompare[1]}`, 0, false, 'group6Div', sizesToCompare[1], sizesToCompare[1], true, false); 
      _drawInternal(`canvas_group6Div_m1_0_${sizesToCompare[2]}`, 0, false, 'group6Div', sizesToCompare[2], sizesToCompare[2], true, false); 
      _drawInternal(`canvas_group6Div_m1_0_${sizesToCompare[3]}`, 0, false, 'group6Div', sizesToCompare[3], sizesToCompare[3], true, false); 
      _drawInternal(`canvas_group6Div_m1_0_${sizesToCompare[4]}`, 0, false, 'group6Div', sizesToCompare[4], sizesToCompare[4], true, false); 
  };

  function _drawInternal(canvasId, angleValue, fillLeftBlack, targetDivId, newCanvasWidth, newCanvasHeight, hideLabel, hideOutlines) {
    const container = document.createElement('div');
    container.className = 'canvas-container';

    const canvas = document.createElement('canvas');
    canvas.id = canvasId;
    canvas.width = newCanvasWidth;
    canvas.height = newCanvasHeight;
    container.appendChild(canvas);

    if (!hideLabel) {
        const label = document.createElement('div');
        label.className = 'label';
        // 為了方便除錯，這裡可以顯示 fillLeftBlack 的值
        label.textContent = `角度值: ${angleValue} (L:${fillLeftBlack}) (${newCanvasWidth}x${newCanvasHeight})`;
        container.appendChild(label);
    }

    const targetDiv = document.getElementById(targetDivId);
    if (targetDiv) {
        targetDiv.appendChild(container);
    } else {
        console.error(`找不到 ID 為 "${targetDivId}" 的容器 div。將圖形添加到 body。`);
        document.body.appendChild(container);
    }

    const ctx = canvas.getContext('2d');
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    
    const circleRadius = (Math.min(canvas.width, canvas.height) / 2) * FIXED_RADIUS_RATIO_X - FIXED_RADIUS_OFFSET_Y;

    ctx.save();
    ctx.translate(centerX, centerY);
    ctx.rotate(FIXED_ROTATION_DEGREES * Math.PI / 180);
    ctx.translate(-centerX, -centerY);

    // 月亮底圖始終填滿整個 Canvas
    if (moonImage.complete && moonImage.naturalWidth > 0) {
        ctx.drawImage(moonImage, 0, 0, newCanvasWidth, newCanvasHeight); 
    } else {
        ctx.fillStyle = 'black'; 
        ctx.fillRect(0, 0, newCanvasWidth, newCanvasHeight);
    }

    // 月相填充邏輯：根據各組的 angleValue 和 fillLeftBlack 獨立判斷
    if (!hideOutlines) { // 只在前五組進行月相填充
        ctx.beginPath();
        ctx.arc(centerX, centerY, circleRadius, 0, 2 * Math.PI); 
        ctx.clip(); // 將繪圖區域裁剪為這個圓形

        let isFullMoon = false;
        let isNewMoon = false;

        if (fillLeftBlack) { // 第一組的定義：0是新月，100是滿月
            if (angleValue === 0) { // 新月
                isNewMoon = true;
            } else if (angleValue === 100) { // 滿月
                isFullMoon = true;
            }
        } else { // 第二組的定義：0是滿月，100是新月
            if (angleValue === 0) { // 滿月
                isFullMoon = true;
            } else if (angleValue === 100) { // 新月
                isNewMoon = true;
            }
        }

        if (isNewMoon) { // 新月 (全黑)
            ctx.fillStyle = MOON_COLOR_DARK;
            ctx.fillRect(centerX - circleRadius, centerY - circleRadius, circleRadius * 2, circleRadius * 2);
        } else if (isFullMoon) { // 滿月 (完全透出底圖，不進行任何填充)
            // 不做任何填充操作
        } else { // 其他月相 (部分陰影)
            // 這裡的 angleValue 0-100 仍然代表月相的百分比
            // observationAngleRadians 應該從 0 (滿月) 到 PI (新月)
            // 為此，我們需要根據當前組的 angleValue 定義來計算正確的 phase 角度
            let phaseAngle = (angleValue / 100) * Math.PI; // 這對 fillLeftBlack=true (0新月100滿月) 的組是正確的
                                                           // 對於 fillLeftBlack=false (0滿月100新月) 的組也應如此
                                                           // 因為 angleValue 增加，陰影面積應該增加，
                                                           // cos 值應從 1 (亮) 變到 -1 (暗)

            const semiMinorAxis_horizontal = circleRadius * Math.cos(phaseAngle);
            const semiMajorAxis_vertical = circleRadius; 
            const currentAbsoluteSemiMinorAxis = Math.abs(semiMinorAxis_horizontal); 

            for (let y = centerY - circleRadius; y <= centerY + circleRadius; y += renderDensity) {
              const dy = y - centerY;
              const dxGreen = Math.sqrt(Math.pow(circleRadius, 2) - Math.pow(dy, 2));
              const greenLeftX = centerX - dxGreen;
              const greenRightX = centerX + dxGreen;

              let redArcX = null; 
              const discriminant = 1 - Math.pow(dy, 2) / Math.pow(semiMajorAxis_vertical, 2);
              
              if (discriminant >= 0) { 
                const dxRed = currentAbsoluteSemiMinorAxis * Math.sqrt(discriminant);
                
                if (semiMinorAxis_horizontal >= 0) { 
                    redArcX = centerX + dxRed;
                } else { 
                    redArcX = centerX - dxRed;
                }
              }
              if (redArcX !== null) {
                  redArcX = Math.max(greenLeftX, Math.min(greenRightX, redArcX));
              } else {
                  if (semiMinorAxis_horizontal >= 0) { 
                      redArcX = greenLeftX; 
                  } else { 
                      redArcX = greenRightX; 
                  }
              }

              ctx.fillStyle = MOON_COLOR_DARK; // 填充顏色為黑色
              if (fillLeftBlack) {
                ctx.fillRect(greenLeftX, y, redArcX - greenLeftX, renderDensity);
              } else {
                ctx.fillRect(redArcX, y, greenRightX - redArcX, renderDensity);
              }
            }
        }
    }

    // 繪製輪廓線和中心點
    if (!hideOutlines) { 
        // 繪製綠色圓形外框 
        ctx.beginPath();
        ctx.arc(centerX, centerY, circleRadius, 0, 2 * Math.PI);
        ctx.strokeStyle = 'green'; 
        ctx.lineWidth = 1;
        ctx.stroke();

        // 只有在需要繪製紅線時才繪製 (非滿月且非新月)
        let drawRedLine = true;
        if (fillLeftBlack) { // 第一組的定義
            if (angleValue === 0 || angleValue === 100) { // 新月或滿月
                drawRedLine = false;
            }
        } else { // 第二組的定義
            if (angleValue === 0 || angleValue === 100) { // 滿月或新月
                drawRedLine = false;
            }
        }

        if (drawRedLine) {
            // 這裡的 observationAngleRadians 仍然需要根據當前組的 angleValue 定義來計算
            let phaseAngle = (angleValue / 100) * Math.PI;

            const semiMinorAxis_horizontal = circleRadius * Math.cos(phaseAngle);
            const semiMajorAxis_vertical = circleRadius; 
            const currentAbsoluteSemiMinorAxis = Math.abs(semiMinorAxis_horizontal); 

            let redArcOutlineStartAngle, redArcOutlineEndAngle;
            // 紅線的繪製方向應該始終與填充方向一致
            // 如果 fillLeftBlack 為 true，陰影在左，亮面在右，紅線應該在右邊 (半圓)
            // 如果 fillLeftBlack 為 false，陰影在右，亮面在左，紅線應該在左邊 (半圓)
            if (fillLeftBlack) { // 亮面在右
                redArcOutlineStartAngle = -Math.PI / 2;
                redArcOutlineEndAngle = Math.PI / 2;
            } else { // 亮面在左
                redArcOutlineStartAngle = Math.PI / 2;
                redArcOutlineEndAngle = 3 * Math.PI / 2;
            }
            // 但如果 semiMinorAxis_horizontal 是負數 (陰影面積超過一半)，這個角度計算邏輯需要反轉
            // 最簡單的方式是保持紅線只畫半個橢圓，而這個半橢圓的方向由 semiMinorAxis_horizontal 的正負決定
            // 由於 semiMinorAxis_horizontal 已經考慮了 cos(phaseAngle) 的正負，這裡無需額外反轉
            // 我們只需確保橢圓的「長軸」永遠是垂直的 (semiMajorAxis_vertical)，而「短軸」是水平的 (currentAbsoluteSemiMinorAxis)

            // 為了簡化，直接根據 semiMinorAxis_horizontal 的正負判斷紅線左右
            if (semiMinorAxis_horizontal >= 0) { // 陰影小於一半，亮面大於一半 (右側是亮面)
                redArcOutlineStartAngle = -Math.PI / 2;
                redArcOutlineEndAngle = Math.PI / 2;
            } else { // 陰影大於一半，亮面小於一半 (左側是亮面)
                redArcOutlineStartAngle = Math.PI / 2;
                redArcOutlineEndAngle = 3 * Math.PI / 2;
            }


            ctx.beginPath();
            const redOutlinePoint1X = centerX + currentAbsoluteSemiMinorAxis * Math.cos(redArcOutlineStartAngle);
            const redOutlinePoint1Y = centerY + semiMajorAxis_vertical * Math.sin(redArcOutlineStartAngle);
            
            ctx.moveTo(redOutlinePoint1X, redOutlinePoint1Y);
            const numSegments = 100;
            for (let i = 0; i <= numSegments; i++) {
                const t = redArcOutlineStartAngle + (redArcOutlineEndAngle - redArcOutlineStartAngle) * (i / numSegments);
                const x = centerX + currentAbsoluteSemiMinorAxis * Math.cos(t);
                const y = centerY + semiMajorAxis_vertical * Math.sin(t);
                ctx.lineTo(x, y);
            }
            ctx.strokeStyle = 'red'; 
            ctx.lineWidth = 3;
            ctx.stroke();
        }

        // 繪製藍色圓心點
        ctx.beginPath();
        ctx.arc(centerX, centerY, 2, 0, 2 * Math.PI);
        ctx.fillStyle = 'blue'; 
        ctx.fill();
    } else {
        // 如果 hideOutlines 為 true（第六組），只畫綠色外框
        ctx.beginPath();
        ctx.arc(centerX, centerY, circleRadius, 0, 2 * Math.PI);
        ctx.strokeStyle = 'green';
        ctx.lineWidth = 1;
        ctx.stroke();
    }

    ctx.restore(); 
  }

  // funcm1 的定義保持不變
  function funcm1(targetDivId, size, hideLabel = false, hideOutlines = false) {
      for (let i = 0; i <= gridSize; i++) {
          const angleValue = i * 10;
          // 第一組的定義：0是新月，100是滿月，fillLeftBlack = true
          _drawInternal(`canvas_${targetDivId}_m1_${angleValue}_${size}_${hideLabel}_${hideOutlines}`, angleValue, true, targetDivId, size, size, hideLabel, hideOutlines); 
      }
  }

  // funcm2 的定義保持不變
  function funcm2(targetDivId, size, hideLabel = false, hideOutlines = false) {
      for (let i = 0; i <= gridSize; i++) {
          const angleValue = i * 10;
          // 第二組的定義：0是滿月，100是新月，fillLeftBlack = false
          _drawInternal(`canvas_${targetDivId}_m2_${angleValue}_${size}_${hideLabel}_${hideOutlines}`, angleValue, false, targetDivId, size, size, hideLabel, hideOutlines); 
      }
  }
</script>

</body>
</html>