<!DOCTYPE html>
<html>
<head>
<title>圓形弧線水平線填色測試 (V28 - 雙色填充 + 月亮背景)</title>
<style>
  body {
    display: flex;
    flex-wrap: wrap;
    justify-content: flex-start;
    align-items: flex-start;
    padding: 20px;
    font-family: sans-serif;
    background-color: #333;
  }
  .page-version-info {
    width: 100%;
    text-align: right;
    font-size: 12px;
    color: #999;
    margin-bottom: 15px;
    padding-bottom: 5px;
    border-bottom: 1px dashed #666;
  }
  .section-title {
    width: 100%;
    margin-top: 20px;
    margin-bottom: 10px;
    font-size: 18px;
    font-weight: bold;
    color: #eee;
    border-bottom: 1px solid #777;
    padding-bottom: 5px;
  }
  .canvas-container {
    margin: 10px;
    border: 1px solid #555;
    box-shadow: 2px 2px 5px rgba(0,0,0,0.5);
    position: relative;
  }
  canvas {
    background-color: black;
  }
  .label {
    text-align: center;
    font-size: 14px;
    margin-top: 5px;
    color: #ccc;
  }
  .drawing-group-container {
      border: 2px dashed #666;
      padding: 10px;
      margin: 20px 0;
      width: 100%;
      box-sizing: border-box;
      display: flex;
      flex-wrap: wrap;
      justify-content: flex-start;
      align-items: flex-start;
  }
</style>
</head>
<body>

<div class="page-version-info">當前版本: V28</div>

<div class="section-title">第一組: 顯示所有文字，顯示線條圓心 (旋轉 24.5 度)</div>
<div id="group1Div" class="drawing-group-container">
    </div>

<div class="section-title" style="clear: both;">第二組: 隱藏所有文字，顯示線條圓心 (旋轉 24.5 度)</div>
<div id="group2Div" class="drawing-group-container">
    </div>

<div class="section-title" style="clear: both;">第三組: 隱藏所有文字，隱藏所有線條圓心 (旋轉 24.5 度)</div>
<div id="group3Div" class="drawing-group-container">
    </div>

<div class="section-title" style="clear: both;">第四組: 顯示所有文字，隱藏所有線條圓心 (旋轉 24.5 度)</div>
<div id="group4Div" class="drawing-group-container">
    </div>

<div class="section-title" style="clear: both;">第五組: 隱藏所有文字，隱藏所有線條圓心 (旋轉 24.5 度)</div>
<div id="group5Div" class="drawing-group-container">
    </div>

<script>
  const gridSize = 10;
  const renderDensity = 1;
  const ANTI_ALIASING_OFFSET = 0.5; // 目前這個版本其實不需要，因為是雙色填充，但先保留
  const FIXED_ROTATION_DEGREES = 24.5;

  const MOON_COLOR_LIGHT = '#e0e0e0';
  const MOON_COLOR_DARK = 'black'; // 月亮的暗面，現在是直接繪製的純黑

  // 載入月亮圖片
  const moonImage = new Image();
  moonImage.src = 'https://raeltw.github.io/wea.tw/moon/moon256.png';

  // 等待圖片載入完成後才開始繪製，確保圖片可用
  moonImage.onload = () => {
      // 圖片載入完成後才調用繪圖函數
      funcm1('group1Div', 200);
      funcm2('group2Div', 250, true, false);
      funcm1('group3Div', 180, true, true);
      funcm2('group4Div', 220, false, true);
      funcm1('group5Div', 150, true, true);
  };

  // 如果圖片載入失敗，給出提示
  moonImage.onerror = () => {
      console.error('月亮圖片載入失敗。請檢查圖片路徑或網路連接。');
      // 即使圖片載入失敗，也繪製不帶圖片的月相圖，避免頁面空白
      funcm1('group1Div', 200);
      funcm2('group2Div', 250, true, false);
      funcm1('group3Div', 180, true, true);
      funcm2('group4Div', 220, false, true);
      funcm1('group5Div', 150, true, true);
  };

  function _drawInternal(canvasId, angleValue, fillLeftBlack, targetDivId, newCanvasWidth, newCanvasHeight, hideLabel, hideOutlines) {
    const container = document.createElement('div');
    container.className = 'canvas-container';

    const canvas = document.createElement('canvas');
    canvas.id = canvasId;
    canvas.width = newCanvasWidth;
    canvas.height = newCanvasHeight;
    container.appendChild(canvas);

    if (!hideLabel) {
        const label = document.createElement('div');
        label.className = 'label';
        label.textContent = `角度值: ${angleValue} (${newCanvasWidth}x${newCanvasHeight})`;
        container.appendChild(label);
    }

    const targetDiv = document.getElementById(targetDivId);
    if (targetDiv) {
        targetDiv.appendChild(container);
    } else {
        console.error(`找不到 ID 為 "${targetDivId}" 的容器 div。將圖形添加到 body。`);
        document.body.appendChild(container);
    }

    const ctx = canvas.getContext('2d');
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    const circleRadius = Math.min(canvas.width, canvas.height) / 2 - 5;

    ctx.save();
    ctx.translate(centerX, centerY);
    ctx.rotate(FIXED_ROTATION_DEGREES * Math.PI / 180);
    ctx.translate(-centerX, -centerY);

    // *** 新增：繪製背景月亮圖片 (目前繪製在左上角，尺寸為圖片原始尺寸) ***
    // 假設月亮圖片的原始尺寸為 256x256
    // 您將在稍後指示如何精確定位和縮放它
    if (moonImage.complete && moonImage.naturalWidth > 0) { // 確保圖片已載入
        ctx.drawImage(moonImage, 0, 0, newCanvasWidth, newCanvasHeight); // 將圖片縮放到 Canvas 大小
    } else {
        // 如果圖片未載入或載入失敗，則填充一個背景色以避免空白
        ctx.fillStyle = '#1a1a1a'; // 深灰色作為圖片載入失敗的預設背景
        ctx.fillRect(0, 0, newCanvasWidth, newCanvasHeight);
    }
    // ********************************************

    // *** 恢復雙色填充邏輯 ***
    // 先繪製一個完整的圓，作為月球的底色（避免透明部分透出背景）
    ctx.beginPath();
    ctx.arc(centerX, centerY, circleRadius, 0, 2 * Math.PI); // 不再加 ANTI_ALIASING_OFFSET，因為是雙色填充
    ctx.fillStyle = MOON_COLOR_DARK; // 預設填充為暗面色
    ctx.fill();

    const observationAngleRadians = (angleValue / 100) * Math.PI;

    const semiMinorAxis_horizontal = circleRadius * Math.cos(observationAngleRadians);
    const semiMajorAxis_vertical = circleRadius;
    const currentAbsoluteSemiMinorAxis = Math.abs(semiMinorAxis_horizontal);

    for (let y = centerY - circleRadius; y <= centerY + circleRadius; y += renderDensity) {
      const dy = y - centerY;
      const dxGreen = Math.sqrt(Math.pow(circleRadius, 2) - Math.pow(dy, 2));
      const greenLeftX = centerX - dxGreen;
      const greenRightX = centerX + dxGreen;

      let redArcX = null;

      const discriminant = 1 - Math.pow(dy, 2) / Math.pow(semiMajorAxis_vertical, 2);

      if (discriminant >= 0) {
        const dxRed = currentAbsoluteSemiMinorAxis * Math.sqrt(discriminant);

        if (semiMinorAxis_horizontal >= 0) {
            redArcX = centerX + dxRed;
        } else {
            redArcX = centerX - dxRed;
        }
      }

      if (redArcX !== null) {
          redArcX = Math.max(greenLeftX, Math.min(greenRightX, redArcX));
      } else {
          if (semiMinorAxis_horizontal >= 0) {
              redArcX = greenLeftX;
          } else {
              redArcX = greenRightX;
          }
      }

      // 恢復雙色填充：左側填充一種顏色，右側填充另一種顏色
      ctx.fillStyle = fillLeftBlack ? MOON_COLOR_DARK : MOON_COLOR_LIGHT;
      ctx.fillRect(greenLeftX, y, redArcX - greenLeftX, renderDensity);

      ctx.fillStyle = fillLeftBlack ? MOON_COLOR_LIGHT : MOON_COLOR_DARK;
      ctx.fillRect(redArcX, y, greenRightX - redArcX, renderDensity);
    }
    // ********************************************

    if (!hideOutlines) {
        ctx.beginPath();
        ctx.arc(centerX, centerY, circleRadius, 0, 2 * Math.PI);
        ctx.strokeStyle = 'green';
        ctx.lineWidth = 1;
        ctx.stroke();

        let redArcOutlineStartAngle, redArcOutlineEndAngle;
        if (semiMinorAxis_horizontal >= 0) {
            redArcOutlineStartAngle = -Math.PI / 2;
            redArcOutlineEndAngle = Math.PI / 2;
        } else {
            redArcOutlineStartAngle = Math.PI / 2;
            redArcOutlineEndAngle = 3 * Math.PI / 2;
        }

        ctx.beginPath();
        const redOutlinePoint1X = centerX + currentAbsoluteSemiMinorAxis * Math.cos(redArcOutlineStartAngle);
        const redOutlinePoint1Y = centerY + semiMajorAxis_vertical * Math.sin(redArcOutlineStartAngle);

        ctx.moveTo(redOutlinePoint1X, redOutlinePoint1Y);
        const numSegments = 100;
        for (let i = 0; i <= numSegments; i++) {
            const t = redArcOutlineStartAngle + (redArcOutlineEndAngle - redArcOutlineStartAngle) * (i / numSegments);
            const x = centerX + currentAbsoluteSemiMinorAxis * Math.cos(t);
            const y = centerY + semiMajorAxis_vertical * Math.sin(t);
            ctx.lineTo(x, y);
        }
        ctx.strokeStyle = 'red';
        ctx.lineWidth = 3;
        ctx.stroke();

        ctx.beginPath();
        ctx.arc(centerX, centerY, 2, 0, 2 * Math.PI);
        ctx.fillStyle = 'blue';
        ctx.fill();
    }

    ctx.restore();
  }

  function funcm1(targetDivId, size, hideLabel = false, hideOutlines = false) {
      for (let i = 0; i <= gridSize; i++) {
          const angleValue = i * 10;
          _drawInternal(`canvas_${targetDivId}_m1_${angleValue}_${size}_${hideLabel}_${hideOutlines}`, angleValue, true, targetDivId, size, size, hideLabel, hideOutlines);
      }
  }

  function funcm2(targetDivId, size, hideLabel = false, hideOutlines = false) {
      for (let i = 0; i <= gridSize; i++) {
          const angleValue = i * 10;
          _drawInternal(`canvas_${targetDivId}_m2_${angleValue}_${size}_${hideLabel}_${hideOutlines}`, angleValue, false, targetDivId, size, size, hideLabel, hideOutlines);
      }
  }

  // --- 頁面加載後調用這些函數來生成圖形 ---
  // 注意：繪圖函數現在在 moonImage.onload 中調用，以確保圖片準備就緒。
  // 如果圖片沒有載入完成，或載入失敗，這些函數也會在 onerror 中被調用。
  // 這樣確保頁面不會因為圖片延遲或失敗而空白。
</script>

</body>
</html>