<!-- 
 file:///D:/mw251.html?key=CWA-422C592A-18E7-4C2E-BBD2-003CCC1F18D4;&station1=466881;&city1=069;&town1=新店區;
 https://raeltw.github.io/wea.tw/mw251.html?key=CWA-422C592A-18E7-4C2E-BBD2-003CCC1F18D4;&station1=466881;&city1=069;&town1=新店區;
Netlify rael.tw ss_aa_60412
 -->

<!DOCTYPE html>
<html lang='zh-Hant'>
<head>

    <meta charset='UTF-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0'>
    <title>天氣預報 '25 - 我一定要挑戰成功!!</title>

<style>

body 
{
    padding: 4px;
    background-color: #000;
    color: #aaa;
    /* color: #ff0; */
}

.undeline
{
   border-bottom: 1px solid #444; 
   margin-bottom: 8px;
}

.chart-container {
   height: 408px !important;
   width: 960px;
}

</style>

</head>

<body>

    
<div id='api_data1'>現在天氣:<br /></div>

<div id='api_data3'>3日預報:<br /></div>
<div class="chart-container">
    <canvas id="Chart3"></canvas>
</div>
<div id='3darea' class='undeline'>3 Days<br />
</div>

<div id='1wdarea' class='undeline'>1 Week<br /></div>

<!-- 這些是工作區 或許等開發完 可以藏起來 -->
<div id='testarea' class='undeline'>TEST<br /></div>
<div id='nowarea' class='undeline'>NOW<br /></div>


<!-- 繪圖工具 -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@2.2.1"></script>


<script>
// 共用函數


//C
function dtcalct(_dt0, _n1) {
    // 1. 解析輸入字串 '年-月-日-時' 為 Date 物件
    // 將 "2025-06-25-15" 轉換為 Date 物件可解析的格式，例如 "2025-06-25T15:00:00"
    const parts = _dt0.split('-'); // 分割成 ['2025', '06', '25', '15']

    if (parts.length !== 4) {
        console.error("dtcalct 錯誤：日期時間字串格式不正確，應為 'YYYY-MM-DD-HH'");
        return null; // 返回 null 或拋出錯誤，表示無效輸入
    }

    const year = parseInt(parts[0], 10);
    const month = parseInt(parts[1], 10) - 1; // 月份在 JavaScript Date 物件中是 0-11
    const day = parseInt(parts[2], 10);
    const hour = parseInt(parts[3], 10);

    // 建立一個 Date 物件。注意：如果沒有指定分鐘和秒，它們會預設為 0
    // 使用 UTC 時間可以避免時區問題，確保加減結果的準確性
    const dateObj = new Date(Date.UTC(year, month, day, hour, 0, 0));

    // 2. 對小時進行加減運算
    dateObj.setUTCHours(dateObj.getUTCHours() + _n1);

    // 3. 將結果格式化回 '年-月-日-時' 字串

    // 獲取新的日期時間組件
    const newYear = dateObj.getUTCFullYear();
    // getUTCMonth() 返回 0-11，所以需要 +1
    const newMonth = (dateObj.getUTCMonth() + 1).toString().padStart(2, '0');
    const newDay = dateObj.getUTCDate().toString().padStart(2, '0');
    const newHour = dateObj.getUTCHours().toString().padStart(2, '0');

    // 拼接成目標格式
    return `${newYear}-${newMonth}-${newDay}-${newHour}`;
}


//M
function makeA(_str, _url) 
{ // 產生 a 連結 <a href="https://example.com" target="_blank">Website</a>
  
    _tmp1='<a href="'+_url+'" target="_blank">'+_str+'</a>';
    //window.alert(_tmp1);

    //這寫法比較長 但很容易懂 但傳回去的格式是不同的接收方式
    //let _tmp1 = document.createElement('a');
    //_tmp1.href = _url;
    //_tmp1.textContent = _str;
    //_tmp1.target = '_blank';
    //window.alert(_tmp1);

    return _tmp1;

}


//R
function removeTrailingSemicolon(str) 
{  // 檢查字串是否為空或非字串類型
  if (typeof str !== 'string' || str.length === 0) {
    return str;
  }

  // 使用 replace() 方法和正則表達式
  // /;+$/: 
  //   ;   - 匹配一個分號
  //   +   - 匹配一個或多個（連續的）分號
  //   $   - 匹配字串的結尾
  //   ''  - 替換成空字串 (即刪除匹配到的內容)
  return str.replace(/;+$/, '');
}


//S
function sendmsg(block1, msg1, br1= 1) 
 {  // 傳送訊息到某個區塊
 
   //是否換行 只能0 或1 預設是 1
   br1 = (br1 === 1) ? 1 : 0;
   
   const outputElement = document.getElementById(block1);
   if (outputElement) {
      // *** 重要的安全性考量：將訊息內容作為純文字追加 ***
      // 使用 textContent 可以防止 msg 中的 HTML 標籤被解析，有效避免 XSS 攻擊。
      outputElement.innerHTML += msg1; 

      if (br1=== 1) {
         outputElement.innerHTML += '<br />';
      }
   }
}

/// --- AI寫的 不錯的功能
// START: 共用函數 - showtip (通用區域感應浮動提示)
/**
 * 在指定容器的特定區域內，根據鼠標位置顯示對應的浮動提示。
 * 該提示框會自動適應內容，並嘗試維持高:寬 2:4 的視覺比例，其左下角對齊鼠標。
 *
 * @param {string} containerId - 要偵測的 HTML 元素 ID (例如 'myChartCanvas' 或 'box1')。
 * @param {number} detectionAreaTopPct - 偵測區域相對容器頂部的百分比 (0-100)。
 * @param {number} detectionAreaLeftPct - 偵測區域相對容器左側的百分比 (0-100)。
 * @param {number} detectionAreaBottomPct - 偵測區域相對容器底部的百分比 (0-100)。
 * @param {number} detectionAreaRightPct - 偵測區域相對容器右側的百分比 (0-100)。
 * @param {string} direction - 偵測方向：'LR' (Left-to-Right) 或 'UD' (Up-to-Down)。
 * @param {Array<string>} messagesArray - 包含要顯示的訊息字串陣列。
 * @param {Object} [options={}] - 可選的配置物件。
 * @param {number} [options.tooltipMaxWidth=160] - 浮動提示框的最大寬度。
 * @param {string} [options.tooltipPrefix=''] - 浮動提示框內容的字首 (例如 '天氣: ')。
 */
function showtip(containerId, detectionAreaTopPct, detectionAreaLeftPct, detectionAreaBottomPct, detectionAreaRightPct, direction, messagesArray, options = {}) {

    const containerElement = document.getElementById(containerId);
    if (!containerElement) {
        console.error(`showtip: 找不到 ID 為 '${containerId}' 的容器元素。`);
        return;
    }

    const tooltipMaxWidth = options.tooltipMaxWidth || 160;
    const tooltipPrefix = options.tooltipPrefix || '';

    const customTooltipDiv = document.createElement('div');
    customTooltipDiv.className = 'generic-custom-tooltip'; // 更通用的類名
    
    // 樣式設定：自動適應內容，保持 max-width，並嘗試 2:4 視覺比例
    customTooltipDiv.style.position = 'absolute';
    customTooltipDiv.style.background = 'rgba(0, 0, 0, 0.7)';
    customTooltipDiv.style.color = '#fff';
    customTooltipDiv.style.borderRadius = '5px';
    customTooltipDiv.style.pointerEvents = 'none'; 
    customTooltipDiv.style.opacity = '0'; 
    customTooltipDiv.style.transition = 'opacity 0.2s ease-in-out';
    customTooltipDiv.style.zIndex = '9999'; 
    customTooltipDiv.style.maxWidth = `${tooltipMaxWidth}px`; 
    customTooltipDiv.style.padding = '8px 12px'; 
    customTooltipDiv.style.boxSizing = 'border-box'; 
    customTooltipDiv.style.whiteSpace = 'normal'; 
    customTooltipDiv.style.wordBreak = 'break-word'; 
    customTooltipDiv.style.textAlign = 'left'; 

    document.body.appendChild(customTooltipDiv);

    // 監聽 containerElement 上的鼠標移動事件
    containerElement.addEventListener('mousemove', function(event) {
        const containerRect = containerElement.getBoundingClientRect(); // 容器在視窗中的位置
        // 滑鼠相對於容器左上角的坐標
        const mouseXInContainer = event.clientX - containerRect.left; 
        const mouseYInContainer = event.clientY - containerRect.top;   

        // 計算感應區的實際像素坐標
        const actualDetectionLeft = (containerRect.width * detectionAreaLeftPct) / 100;
        const actualDetectionTop = (containerRect.height * detectionAreaTopPct) / 100;
        const actualDetectionRight = (containerRect.width * detectionAreaRightPct) / 100;
        const actualDetectionBottom = (containerRect.height * detectionAreaBottomPct) / 100;

        // 判斷鼠標是否在感應區內
        const isMouseInDetectionArea = 
            mouseXInContainer >= actualDetectionLeft &&
            mouseXInContainer <= actualDetectionRight &&
            mouseYInContainer >= actualDetectionTop &&
            mouseYInContainer <= actualDetectionBottom;

        let foundMessageIndex = -1;

        if (isMouseInDetectionArea && messagesArray && messagesArray.length > 0) {
            let primaryAxisLength; // 感應區在主軸上的實際長度
            let mousePrimaryCoord; // 滑鼠在主軸上的相對坐標

            if (direction === 'LR') {
                primaryAxisLength = actualDetectionRight - actualDetectionLeft;
                mousePrimaryCoord = mouseXInContainer - actualDetectionLeft;
            } else if (direction === 'UD') {
                primaryAxisLength = actualDetectionBottom - actualDetectionTop;
                mousePrimaryCoord = mouseYInContainer - actualDetectionTop;
            }

            // 計算每個訊息對應的「步長」或「子區域寬度/高度」
            // 為了避免死區，讓每個子區域有適當重疊。
            // 這裡使用一個因子，讓每個子區域的判斷範圍比理論值大一點，確保覆蓋。
            const segmentSize = primaryAxisLength / messagesArray.length;
            const overlapFactor = 1.2; // 例如，每個感應段實際覆蓋 120% 的範圍
            const effectiveSegmentSize = segmentSize * overlapFactor;

            // 根據滑鼠在主軸上的位置計算對應的索引
            // 遍歷所有可能的索引，找到最接近的
            for (let i = 0; i < messagesArray.length; i++) {
                const segmentStart = i * segmentSize;
                const segmentEnd = segmentStart + effectiveSegmentSize; // 考慮重疊

                if (mousePrimaryCoord >= segmentStart && mousePrimaryCoord < segmentEnd) {
                    foundMessageIndex = i;
                    break;
                }
            }
            // 處理邊界情況：如果鼠標在最後一個段的末尾，確保能觸發最後一個
            if (foundMessageIndex === -1 && mousePrimaryCoord >= primaryAxisLength - segmentSize) {
                foundMessageIndex = messagesArray.length - 1;
            }

            if (foundMessageIndex !== -1 && messagesArray[foundMessageIndex]) {
                customTooltipDiv.innerHTML = tooltipPrefix + messagesArray[foundMessageIndex];
                
                // *** 定位邏輯：左下角對齊鼠標 (考慮頁面滾動) ***
                // event.clientX / event.clientY 是鼠標在視窗中的絕對坐標
                // window.scrollX / window.scrollY 是頁面滾動的量
                const tooltipLeft = event.clientX + window.scrollX; 
                const tooltipTop = (event.clientY + window.scrollY) - customTooltipDiv.offsetHeight; 

                customTooltipDiv.style.left = `${tooltipLeft}px`;
                customTooltipDiv.style.top = `${tooltipTop}px`;
                customTooltipDiv.style.opacity = '1';
            } else {
                customTooltipDiv.style.opacity = '0';
            }
        } else {
            customTooltipDiv.style.opacity = '0';
        }
    });

    containerElement.addEventListener('mouseleave', function() {
        customTooltipDiv.style.opacity = '0';
    });
}
// END: 共用函數 - showtip

/// ---

//測試區
       //sendmsg('testarea', '大家好');
       //sendmsg('testarea', '我是王先生');

</script>


 <!--  呼叫 現在觀測 -->
<script src="now1.js"></script>
<script> document.addEventListener('DOMContentLoaded', () => { nowwea1(); } ); </script>

<script>
   //變數陣列在此宣告 才能讓變數傳遞到所有子程序去
   let currentDataIndex = -1; 
   var _dt0=[]; _dt1=[]; _temp0=[]; _temp1=[]; _dew0=[]; _humi0=[]; _prec0=[]; _descl=[];
   // 日期0(原始), 日期1(精簡), 溫度, 體感溫度, 露點溫度, 相對濕度, 降雨機率

</script>
 <!--  呼叫 3日預報 -->
<! -- 帶入順序 要從最底層的開始寫 -->
<script src="3d1chart.js"></script>
<script src="3d1.js"></script>
<script> document.addEventListener('DOMContentLoaded', () => { d31(); } ); </script>

<!-- 
氣象局 1周預報 API 的基本 URL
       // wea3.html?key=CWA-422C592A-18E7-4C2E-BBD2-003CCC1F18D4;&location1=新店區;
-->

</body>

</html>